//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
#include <limits>

//custom
#include "MouseMovement.hpp"

using namespace cv;
using namespace std;

//our sensitivity value to be used in the absdiff() function
const static int SENSITIVITY_VALUE = 50;
//size of blur used to smooth the intensity image output from absdiff() function
const static int BLUR_SIZE = 10;

// Global variables
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard; //input from keyboard
Point maxPoint;
void help();
void processVideo();
void condefects(vector<Vec4i> convexityDefectsSet, vector<Point> mycontour,
		Mat &original);
void showimgcontours(Mat &threshedimg, Mat &original, char* imageType);

void help() {
	cout
			<< "--------------------------------------------------------------------------"
			<< endl
			<< "This program shows how to use background subtraction methods provided by "
			<< endl
			<< " OpenCV. You can process both videos (-vid) and images (-img)."
			<< endl << endl << "Usage:" << endl
			<< "./bg_sub {-vid <video filename>|-img <image filename>}" << endl
			<< "for example: ./bg_sub -vid video.avi" << endl
			<< "or: ./bg_sub -img /data/images/1.png" << endl
			<< "--------------------------------------------------------------------------"
			<< endl << endl;
}
int main1() {

	//print help information
	help();

	//create GUI windows
	namedWindow("Frame");
	namedWindow("FG Mask MOG 2");
	//create Background Subtractor objects
	pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach

	//call to process video
	processVideo();

	//destroy GUI windows
	destroyAllWindows();
	return EXIT_SUCCESS;
}

void erodeAndDilate() {
	erode(frame, frame, Mat());
	dilate(frame, frame, Mat());
	cv::threshold(frame, frame, SENSITIVITY_VALUE, 255, THRESH_BINARY);
}

void blurAndThreshold() {
	//blur the image to get rid of the noise. This will output an intensity image
	cv::blur(frame, frame, cv::Size(BLUR_SIZE, BLUR_SIZE));
	//threshold again to obtain binary image from blur output
	cv::threshold(frame, frame, SENSITIVITY_VALUE, 255, THRESH_BINARY);
}

void processVideo() {
	//create the capture object
	VideoCapture capture(0);
	capture.set(CV_CAP_PROP_FRAME_WIDTH, 1020);
	capture.set(CV_CAP_PROP_FRAME_HEIGHT, 768);

	if (!capture.isOpened()) {
		//error in opening the video input
		cerr << "Unable to open video file: " << endl;
		exit( EXIT_FAILURE);
	}
	//read input data. ESC or 'q' for quitting
	while ((char) keyboard != 'q' && (char) keyboard != 27) {
		//read the current frame
		if (!capture.read(frame)) {
			cerr << "Unable to read next frame." << endl;
			cerr << "Exiting..." << endl;
			exit( EXIT_FAILURE);
		}

		//Backup of original image
		Mat originalImage = frame;

		//convert to gray
		cvtColor(frame, frame, COLOR_BGR2GRAY);
		threshold(frame, frame, 100, 255, THRESH_BINARY_INV);
		blurAndThreshold();

		erodeAndDilate();

		//update the background model
		pMOG2->apply(frame, fgMaskMOG2);
		//get the frame number and write it on the current frame
		stringstream ss;
		rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
				cv::Scalar(255, 255, 255), -1);
		ss << capture.get(CAP_PROP_POS_FRAMES);
		string frameNumberString = ss.str();
		putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
				FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
		//show the current frame and the fg masks
		imshow("Frame", frame);
		imshow("FG Mask MOG 2", fgMaskMOG2);

		//threshold image
		Mat thresholdImage;
		threshold(fgMaskMOG2, thresholdImage, 100, 255, THRESH_BINARY);

		//blur the image to get rid of the noise. This will output an intensity image
		cv::blur(thresholdImage, thresholdImage, cv::Size(BLUR_SIZE, BLUR_SIZE));

		//threshold again to obtain binary image from blur output
		cv::threshold(thresholdImage, thresholdImage, SENSITIVITY_VALUE, 255,
				THRESH_BINARY);

		//Enhance edges in the foreground by applying erosion and dilation
		/*erode(fgMaskMOG2,fgMaskMOG2,Mat());
		 dilate(fgMaskMOG2,fgMaskMOG2,Mat());*/
		imshow("Subtracted threshold image", thresholdImage);

		showimgcontours(thresholdImage, originalImage, "Final Subracted Image");
		//showimgcontours(frame, originalImage, "Final Threshold Image");

		//get the input from the keyboard
		keyboard = waitKey(30);
	}
	//delete capture object
	capture.release();
}

void showimgcontours(Mat &threshedimg, Mat &original, char* imageType) {
	vector<vector<Point> > contours;
	vector<Vec4i> hierarchy;
	int largest_area = 0;
	int largest_contour_index = 0;

	//findContours(threshedimg, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));
	findContours(threshedimg, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);

	/// Find the convex hull,contours and defects for each contour
	vector<vector<Point> > hull(contours.size());
	vector<vector<int> > inthull(contours.size());
	vector<vector<Vec4i> > defects(contours.size());
	for (int i = 0; i < contours.size(); i++) {
		convexHull(Mat(contours[i]), hull[i], false);
		convexHull(Mat(contours[i]), inthull[i], false);
		if (inthull[i].size() > 3)
			convexityDefects(contours[i], inthull[i], defects[i]);
	}
	//find  hulland contour and defects end here

	//this will find largest contour
	for (int i = 0; i < contours.size(); i++) // iterate through each contour.
	{
		double a = contourArea(contours[i], false); //  Find the area of contour
		if (a > largest_area) {
			largest_area = a;
			largest_contour_index = i; //Store the index of largest contour
		}

	}
	//search for largest contour has end

	if (contours.size() > 0) {
		if (contourArea(contours[largest_contour_index]) >= 500) {
			drawContours(original, contours, largest_contour_index,
					CV_RGB(0, 255, 0), 2, 8, hierarchy, 0);
			//if want to show all contours use below one
			//drawContours(original,contours,-1, CV_RGB(0, 255, 0), 2, 8, hierarchy);
			//if (showhull)
			drawContours(original, hull, largest_contour_index,
					CV_RGB(0, 0, 255), 2, 8, hierarchy, 0);
			//if want to show all hull, use below one
			//drawContours(original,hull,-1, CV_RGB(0, 255, 0), 2, 8, hierarchy);
			//if (showcondefects)
			condefects(defects[largest_contour_index],
					contours[largest_contour_index], original);
			stringstream ss;
			ss << maxPoint.x << "-" << maxPoint.y;
			putText(original, ss.str(), cv::Point(100, 100),
					FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 1, 8,
					false);
			Point2f center;
			float radius;
			minEnclosingCircle(contours[largest_contour_index], center, radius);

			// Draw a circle
			circle(original, center, radius, Scalar(0, 0, 255), 1, 8);
			imshow(imageType, original);

			SetMousePosition(maxPoint.x, maxPoint.y);
		}
	}
}

void condefects(vector<Vec4i> convexityDefectsSet, vector<Point> mycontour,
		Mat &original) {

	maxPoint.x = std::numeric_limits<int>::max();
	maxPoint.y = std::numeric_limits<int>::max();

	for (int cDefIt = 0; cDefIt < convexityDefectsSet.size(); cDefIt++) {

		int startIdx = convexityDefectsSet[cDefIt].val[0];
		Point ptStart(mycontour[startIdx]);

		if (ptStart.x < maxPoint.x) {
			maxPoint.x = ptStart.x;
			maxPoint.y = ptStart.y;
		}

		int endIdx = convexityDefectsSet[cDefIt].val[1];
		Point ptEnd(mycontour[endIdx]);

		int farIdx = convexityDefectsSet[cDefIt].val[2];
		Point ptFar(mycontour[farIdx]);

		double depth = static_cast<double> (convexityDefectsSet[cDefIt].val[3])
				/ 256;
		//cout << "depth" << depth << endl;
		//display start points
		circle(original, ptStart, 5, CV_RGB(255,0,0), 2, 8);
		//display all end points
		//circle(original, ptEnd, 5, CV_RGB(255, 255, 0), 2, 8);
		//display all far points
		//circle(original,ptFar,5,CV_RGB(0,0,255),2,8);
	}
}// condefects ends here
